<?php
/**
 * @file
 * Fires watchdog messages to mongodb.
 */
use Drupal\Component\Utility\Settings;

/**
 * Implements hook_page_build().
 */
function mongodb_watchdog_page_build(&$page) {
  if (arg(0) == 'admin' && arg(1) == 'reports') {
    $page['#attached']['css'][] = drupal_get_path('module', 'mongodb_watchdog') . '/css/mongodb_watchdog.module.css';
  }
}

/**
 * Implements hook_watchdog().
 *
 * Refer to issue #1355808 regarding filtering.
 *
 * @link http://drupal.org/node/1355808
 */
function mongodb_watchdog_watchdog(array $log_entry) {
  $watchdog_limit = Settings::get('watchdog_limit', WATCHDOG_DEBUG);
  if (isset($log_entry['severity']) && $log_entry['severity'] > $watchdog_limit) {
    return;
  }

  // Find the function that generated this error.
  $log_entry = (array) $log_entry;
  _mongodb_watchdog_enhance_log_entry($log_entry, debug_backtrace());

  /** @var \Drupal\Core\Session\UserSession $account */
  $account = $log_entry['user'];

  // Special handling for core bug #904994:
  if (!isset($log_entry['variables'])) {
    $special_messages = array(
      'page not found' => 'Page not found: @param',
      'access denied'  => 'Access denied: @param',
    );
    $type = $log_entry['type'];
    $log_entry['variables'] = array('@param' => $log_entry['message']);
    $log_entry['message'] = isset($special_messages[$type])
      ? $special_messages[$log_entry['type']]
      : '@param';
  }

  $event = array(
    'variables' => $log_entry['variables'],
    'timestamp' => $log_entry['timestamp'],
    'user' => array(
      'name' => $account->getUsername($account->name),
      'uid' => $log_entry['uid'],
    ),
    'ip' => $log_entry['ip'],
    'request_uri' => $log_entry['request_uri'],
    'referer' => $log_entry['referer'],
    'link' => $log_entry['link'],
  );
  unset(
    $log_entry['ip'],
    $log_entry['link'],
    $log_entry['referer'],
    $log_entry['request_uri'],
    $log_entry['user'],
    $log_entry['variables']
  );

  /** @var \Drupal\mongodb\Logger\Logger $mongo */
  $logger = Drupal::service('mongo.logger');

  $collection = $logger->templatesCollection();
  $id = md5($log_entry['function']
    . ':' . $log_entry['line']
    . ':' . $log_entry['severity']
    . ':' . $log_entry['type']
    . ':' . $log_entry['message']);

  $criteria = array(
    '_id' => $id,
  );
  $update = array(
    '$set' => $log_entry,
    '$inc' => array('count' => 1),
  );
  $options = array(
    'upsert' => TRUE,
  );
  $collection->update($criteria, $update, $options);

  $result = $collection->db->command(array('getlasterror' => 1));
  $collection = $collection->db->selectCollection('watchdog_event_' . $id);
  if (empty($result['updatedExisting'])) {
    $max = Settings::get('mongodb_watchdog_items', 10000);
    $command = array(
      'create' => $collection->getName(),
      'capped' => TRUE,
      'size' => $max * 1000,
      "max" => $max,
    );
    $collection->db->command($command);
  }
  $collection->insert($event);
}

/**
 * Fill in the log_entry function, file, and line.
 *
 * @param array $log_entry
 * @param array $backtrace
 *
 * @return void
 */
function _mongodb_watchdog_enhance_log_entry(&$log_entry, $backtrace) {
  // Create list of functions to ignore in backtrace.
  static $ignore = array(
    'mongodb_watchdog_watchdog' => 1,
    'call_user_func_array' => 1,
    'module_invoke' => 1,
    'watchdog' => 1,
    '_drupal_log_error' => 1,
    '_drupal_error_handler' => 1,
    '_drupal_error_handler_real' => 1,
    'theme_render_template' => 1,
  );

  foreach ($backtrace as $bt) {
    if (isset($bt['function'])) {
      if (isset($bt['line']) && !isset($ignore[$bt['function']])) {
        if (isset($bt['file'])) {
          $log_entry['file'] = $bt['file'];
        }
        $log_entry['function'] = $bt['function'];
        $log_entry['line'] = $bt['line'];
        break;
      }
      elseif ($bt['function'] == '_drupal_exception_handler') {
        $e = $bt['args'][0];
        _mongodb_watchdog_enhance_log_entry($log_entry, $e->getTrace());
      }
    }
  }
}
